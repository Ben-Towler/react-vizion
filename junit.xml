<?xml version="1.0" encoding="UTF-8"?>
<testsuites name="jest tests" tests="419" failures="1" time="18.093">
  <testsuite name="Highlighter - Highlight" errors="0" failures="0" skipped="0" timestamp="2020-04-17T22:59:53" time="7.075" tests="13">
    <testcase classname="Highlighter - Highlight renders a highlight" name="Highlighter - Highlight renders a highlight" time="0.185">
    </testcase>
    <testcase classname="Highlighter - Highlight renders a nonhighlight" name="Highlighter - Highlight renders a nonhighlight" time="0.001">
    </testcase>
    <testcase classname="Highlighter - simple renders a highlighted value" name="Highlighter - simple renders a highlighted value" time="0.002">
    </testcase>
    <testcase classname="Highlighter - simple renders a non highlighted value" name="Highlighter - simple renders a non highlighted value" time="0.028">
    </testcase>
    <testcase classname="Highlighter - simple renders a highlighted value with a custom tagName" name="Highlighter - simple renders a highlighted value with a custom tagName" time="0.001">
    </testcase>
    <testcase classname="Highlighter - simple renders a highlighted value with a custom nonHighlightedTagName" name="Highlighter - simple renders a highlighted value with a custom nonHighlightedTagName" time="0.001">
    </testcase>
    <testcase classname="Highlighter - simple renders with a custom className" name="Highlighter - simple renders with a custom className" time="0.001">
    </testcase>
    <testcase classname="Highlighter - multi renders a highlighted value" name="Highlighter - multi renders a highlighted value" time="0.001">
    </testcase>
    <testcase classname="Highlighter - multi renders a non highlighted value" name="Highlighter - multi renders a non highlighted value" time="0.001">
    </testcase>
    <testcase classname="Highlighter - multi renders a highlighted value with a custom tagName" name="Highlighter - multi renders a highlighted value with a custom tagName" time="0.001">
    </testcase>
    <testcase classname="Highlighter - multi renders a highlighted value with a custom nonHighlightedTagName" name="Highlighter - multi renders a highlighted value with a custom nonHighlightedTagName" time="0.001">
    </testcase>
    <testcase classname="Highlighter - multi renders a highlighted value with a custom separator" name="Highlighter - multi renders a highlighted value with a custom separator" time="0.045">
    </testcase>
    <testcase classname="Highlighter - multi renders a custom className" name="Highlighter - multi renders a custom className" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="findResultsState" errors="0" failures="0" skipped="0" timestamp="2020-04-17T22:59:53" time="8.101" tests="17">
    <testcase classname="findResultsState throws an error if props are not provided" name="findResultsState throws an error if props are not provided" time="0.004">
    </testcase>
    <testcase classname="findResultsState throws an error if props does not have a `searchClient`" name="findResultsState throws an error if props does not have a `searchClient`" time="0.001">
    </testcase>
    <testcase classname="findResultsState throws an error if props does not have an `indexName`" name="findResultsState throws an error if props does not have an `indexName`" time="0">
    </testcase>
    <testcase classname="findResultsState adds expected Clinia agents" name="findResultsState adds expected Clinia agents" time="0.013">
    </testcase>
    <testcase classname="findResultsState does not throw if `searchClient` does not have a `addCliniaAgent()` method" name="findResultsState does not throw if `searchClient` does not have a `addCliniaAgent()` method" time="0.001">
    </testcase>
    <testcase classname="findResultsState single index results should be state &amp; results" name="findResultsState single index results should be state &amp; results" time="0.003">
    </testcase>
    <testcase classname="findResultsState single index searchParameters should be cleaned each time" name="findResultsState single index searchParameters should be cleaned each time" time="0.002">
    </testcase>
    <testcase classname="findResultsState single index without search state" name="findResultsState single index without search state" time="0.001">
    </testcase>
    <testcase classname="findResultsState single index with search state" name="findResultsState single index with search state" time="0.067">
    </testcase>
    <testcase classname="findResultsState multi index results should be instance of SearchResults and SearchParameters" name="findResultsState multi index results should be instance of SearchResults and SearchParameters" time="0.003">
    </testcase>
    <testcase classname="findResultsState multi index searchParameters should be cleaned each time" name="findResultsState multi index searchParameters should be cleaned each time" time="0.002">
    </testcase>
    <testcase classname="findResultsState multi index without search state - first API" name="findResultsState multi index without search state - first API" time="0.002">
    </testcase>
    <testcase classname="findResultsState multi index without search state - second API" name="findResultsState multi index without search state - second API" time="0.001">
    </testcase>
    <testcase classname="findResultsState multi index without search state - same index" name="findResultsState multi index without search state - same index" time="0.056">
    </testcase>
    <testcase classname="findResultsState multi index with search state - first API" name="findResultsState multi index with search state - first API" time="0.005">
    </testcase>
    <testcase classname="findResultsState multi index with search state - second API" name="findResultsState multi index with search state - second API" time="0.001">
    </testcase>
    <testcase classname="findResultsState multi index with search state - same index" name="findResultsState multi index with search state - same index" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="InfiniteHits" errors="0" failures="0" skipped="0" timestamp="2020-04-17T22:59:53" time="8.265" tests="7">
    <testcase classname="InfiniteHits accepts a hitComponent prop" name="InfiniteHits accepts a hitComponent prop" time="0.095">
    </testcase>
    <testcase classname="InfiniteHits accepts a custom className" name="InfiniteHits accepts a custom className" time="0.028">
    </testcase>
    <testcase classname="InfiniteHits calls refineNext when the load more button is clicked" name="InfiniteHits calls refineNext when the load more button is clicked" time="0.154">
    </testcase>
    <testcase classname="InfiniteHits calls refinePrevious when the load previous button is clicked" name="InfiniteHits calls refinePrevious when the load previous button is clicked" time="0.012">
    </testcase>
    <testcase classname="InfiniteHits render &quot;Show previous&quot; button depending of `showPrevious` prop" name="InfiniteHits render &quot;Show previous&quot; button depending of `showPrevious` prop" time="0.051">
    </testcase>
    <testcase classname="InfiniteHits &quot;Show more&quot; button is disabled when it is the last page" name="InfiniteHits &quot;Show more&quot; button is disabled when it is the last page" time="0.004">
    </testcase>
    <testcase classname="InfiniteHits &quot;Show previous&quot; button is disabled when it is the first page" name="InfiniteHits &quot;Show previous&quot; button is disabled when it is the first page" time="0.023">
    </testcase>
  </testsuite>
  <testsuite name="createConnector" errors="0" failures="0" skipped="0" timestamp="2020-04-17T22:59:53" time="8.366" tests="35">
    <testcase classname="createConnector state computes provided props" name="createConnector state computes provided props" time="0.06">
    </testcase>
    <testcase classname="createConnector state computes provided props on props change" name="createConnector state computes provided props on props change" time="0.077">
    </testcase>
    <testcase classname="createConnector state computes provided props with the correct value for `canRender` on props change" name="createConnector state computes provided props with the correct value for `canRender` on props change" time="0.016">
    </testcase>
    <testcase classname="createConnector state computes provided props on search state change" name="createConnector state computes provided props on search state change" time="0.012">
    </testcase>
    <testcase classname="createConnector state computes provided props with latest props on search state change" name="createConnector state computes provided props with latest props on search state change" time="0.007">
    </testcase>
    <testcase classname="createConnector state does not compute provided props when props do not change" name="createConnector state does not compute provided props when props do not change" time="0.002">
    </testcase>
    <testcase classname="createConnector state use shouldComponentUpdate when provided" name="createConnector state use shouldComponentUpdate when provided" time="0.237">
    </testcase>
    <testcase classname="createConnector state subscribes to the store once mounted" name="createConnector state subscribes to the store once mounted" time="0.002">
    </testcase>
    <testcase classname="createConnector state unsubscribes from the store on unmount" name="createConnector state unsubscribes from the store on unmount" time="0.001">
    </testcase>
    <testcase classname="createConnector state does not throw an error on unmount before mount" name="createConnector state does not throw an error on unmount before mount" time="0.001">
    </testcase>
    <testcase classname="createConnector state does not throw an error on dispatch after unmount" name="createConnector state does not throw an error on dispatch after unmount" time="0.001">
    </testcase>
    <testcase classname="createConnector widget registers itself as a widget with getMetadata" name="createConnector widget registers itself as a widget with getMetadata" time="0.001">
    </testcase>
    <testcase classname="createConnector widget registers itself as a widget with getSearchParameters" name="createConnector widget registers itself as a widget with getSearchParameters" time="0.001">
    </testcase>
    <testcase classname="createConnector widget registers itself as a widget once mounted" name="createConnector widget registers itself as a widget once mounted" time="0.002">
    </testcase>
    <testcase classname="createConnector widget does not register itself as a widget without getMetadata nor getSearchParameters" name="createConnector widget does not register itself as a widget without getMetadata nor getSearchParameters" time="0">
    </testcase>
    <testcase classname="createConnector widget calls onSearchParameters on mount with getSearchParameters" name="createConnector widget calls onSearchParameters on mount with getSearchParameters" time="0">
    </testcase>
    <testcase classname="createConnector widget does not call onSearchParameters on mount without getSearchParameters" name="createConnector widget does not call onSearchParameters on mount without getSearchParameters" time="0.001">
    </testcase>
    <testcase classname="createConnector widget binds getSearchParameters to the connector instance with onSearchParameters" name="createConnector widget binds getSearchParameters to the connector instance with onSearchParameters" time="0.063">
    </testcase>
    <testcase classname="createConnector widget triggers a widgetManager update on props change" name="createConnector widget triggers a widgetManager update on props change" time="0.003">
    </testcase>
    <testcase classname="createConnector widget does not trigger a widgetManager update when props do not change" name="createConnector widget does not trigger a widgetManager update when props do not change" time="0.001">
    </testcase>
    <testcase classname="createConnector widget triggers an onSearchStateChange on props change with transitionState" name="createConnector widget triggers an onSearchStateChange on props change with transitionState" time="0.001">
    </testcase>
    <testcase classname="createConnector widget does not trigger an onSearchStateChange on props change without transitionState" name="createConnector widget does not trigger an onSearchStateChange on props change without transitionState" time="0.005">
    </testcase>
    <testcase classname="createConnector widget unregisters itself on unmount" name="createConnector widget unregisters itself on unmount" time="0.001">
    </testcase>
    <testcase classname="createConnector widget calls onSearchStateChange with cleanUp on unmount" name="createConnector widget calls onSearchStateChange with cleanUp on unmount" time="0.001">
    </testcase>
    <testcase classname="createConnector widget calls onSearchStateChange with cleanUp without empty keys on unmount" name="createConnector widget calls onSearchStateChange with cleanUp without empty keys on unmount" time="0.001">
    </testcase>
    <testcase classname="createConnector widget does not throw an error on unmount before mount" name="createConnector widget does not throw an error on unmount before mount" time="0.001">
    </testcase>
    <testcase classname="createConnector getSearchParameters returns the widget search parameters when getSearchParameters is provided" name="createConnector getSearchParameters returns the widget search parameters when getSearchParameters is provided" time="0.001">
    </testcase>
    <testcase classname="createConnector getSearchParameters returns null when getSearchParameters is not provided" name="createConnector getSearchParameters returns null when getSearchParameters is not provided" time="0">
    </testcase>
    <testcase classname="createConnector getMetadata returns the widget metadata when getMetadata is provided" name="createConnector getMetadata returns the widget metadata when getMetadata is provided" time="0.023">
    </testcase>
    <testcase classname="createConnector getMetadata returns an empty object when getMetadata is not provided" name="createConnector getMetadata returns an empty object when getMetadata is not provided" time="0">
    </testcase>
    <testcase classname="createConnector transitionState returns the widget transitionState when transitionState is provided" name="createConnector transitionState returns the widget transitionState when transitionState is provided" time="0.001">
    </testcase>
    <testcase classname="createConnector transitionState returns the given next state when transitionState is not provided" name="createConnector transitionState returns the given next state when transitionState is not provided" time="0.001">
    </testcase>
    <testcase classname="createConnector refine passes a refine method to the component" name="createConnector refine passes a refine method to the component" time="0.004">
    </testcase>
    <testcase classname="createConnector createURL passes a createURL method to the component" name="createConnector createURL passes a createURL method to the component" time="0.003">
    </testcase>
    <testcase classname="createConnector wrapped with VisionProvider default export reads from context" name="createConnector wrapped with VisionProvider default export reads from context" time="0.049">
    </testcase>
  </testsuite>
  <testsuite name="HitsPerPage" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:00" time="1.764" tests="4">
    <testcase classname="HitsPerPage renders" name="HitsPerPage renders" time="0.127">
    </testcase>
    <testcase classname="HitsPerPage renders with a custom className" name="HitsPerPage renders with a custom className" time="0.002">
    </testcase>
    <testcase classname="HitsPerPage refines its value on change" name="HitsPerPage refines its value on change" time="0.272">
    </testcase>
    <testcase classname="HitsPerPage should use value if no label provided" name="HitsPerPage should use value if no label provided" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="createVisionManager" errors="0" failures="1" skipped="0" timestamp="2020-04-17T22:59:53" time="8.874" tests="21">
    <testcase classname="createVisionManager initializes the manager with an empty state" name="createVisionManager initializes the manager with an empty state" time="0.042">
    </testcase>
    <testcase classname="client hydratation hydrates the `searchClient` for a single index results" name="client hydratation hydrates the `searchClient` for a single index results" time="0.001">
    </testcase>
    <testcase classname="client hydratation hydrates the `searchClient` for a multi index results" name="client hydratation hydrates the `searchClient` for a multi index results" time="0.001">
    </testcase>
    <testcase classname="client hydratation does not hydrate the `searchClient` without results" name="client hydratation does not hydrate the `searchClient` without results" time="0">
    </testcase>
    <testcase classname="client hydratation does not hydrate the `searchClient` if it&apos;s not an Algolia client" name="client hydratation does not hydrate the `searchClient` if it&apos;s not an Algolia client" time="0.001">
    </testcase>
    <testcase classname="client hydratation does not hydrate the `searchClient` without cache enabled" name="client hydratation does not hydrate the `searchClient` without cache enabled" time="0">
    </testcase>
    <testcase classname="results hydratation initializes the manager with a single index hydrated results" name="results hydratation initializes the manager with a single index hydrated results" time="0.001">
    </testcase>
    <testcase classname="results hydratation initializes the manager with a multi index hydrated results" name="results hydratation initializes the manager with a multi index hydrated results" time="0.001">
    </testcase>
    <testcase classname="widget manager triggers a search when a widget is added" name="widget manager triggers a search when a widget is added" time="0.036">
    </testcase>
    <testcase classname="transitionState executes widgets hook" name="transitionState executes widgets hook" time="0.002">
    </testcase>
    <testcase classname="getWidgetsIds returns the list of ids of all registered widgets" name="getWidgetsIds returns the list of ids of all registered widgets" time="0.001">
    </testcase>
    <testcase classname="getSearchParameters expects a widget top level to be shared between main and derived parameters" name="getSearchParameters expects a widget top level to be shared between main and derived parameters" time="0.002">
    </testcase>
    <testcase classname="getSearchParameters expects a widget with the same id than the indexName to be a main parameters" name="getSearchParameters expects a widget with the same id than the indexName to be a main parameters" time="0.001">
    </testcase>
    <testcase classname="getSearchParameters expects a widget with a different id than the indexName to be a derived parameters" name="getSearchParameters expects a widget with a different id than the indexName to be a derived parameters" time="0.001">
    </testcase>
    <testcase classname="getSearchParameters expects a widget within a mutli index context with the same id than the indexName to be a main parameters" name="getSearchParameters expects a widget within a mutli index context with the same id than the indexName to be a main parameters" time="0.001">
    </testcase>
    <testcase classname="getSearchParameters expects a widget within a mutli index context with a different id than the indexName to be a derived parameters" name="getSearchParameters expects a widget within a mutli index context with a different id than the indexName to be a derived parameters" time="0.001">
    </testcase>
    <testcase classname="getSearchParameters expects widgets main parameters and derived parameters to be correctly calculated within a multi index context" name="getSearchParameters expects widgets main parameters and derived parameters to be correctly calculated within a multi index context" time="0.303">
      <failure>Error: expect(received).toEqual(expected) // deep equality

- Expected
+ Received

  Array [
-   ObjectContaining {
-     &quot;indexId&quot;: &quot;bestbuy&quot;,
-     &quot;parameters&quot;: ObjectContaining {
-       &quot;index&quot;: &quot;bestbuy&quot;,
+   Object {
+     &quot;indexId&quot;: &quot;instant_search_microsoft&quot;,
+     &quot;parameters&quot;: SearchParameters {
+       &quot;disjunctiveFacets&quot;: Array [],
+       &quot;disjunctiveFacetsRefinements&quot;: Object {},
+       &quot;facets&quot;: Array [],
+       &quot;facetsExcludes&quot;: Object {},
+       &quot;facetsRefinements&quot;: Object {},
+       &quot;filters&quot;: &quot;brand:Microsoft&quot;,
+       &quot;highlightPostTag&quot;: &quot;&lt;/cvi-highlight-0000000000&gt;&quot;,
+       &quot;highlightPreTag&quot;: &quot;&lt;cvi-highlight-0000000000&gt;&quot;,
+       &quot;index&quot;: &quot;instant_search&quot;,
+       &quot;numericRefinements&quot;: Object {},
      },
    },
-   ObjectContaining {
-     &quot;indexId&quot;: &quot;instant_search&quot;,
-     &quot;parameters&quot;: ObjectContaining {
+   Object {
+     &quot;indexId&quot;: &quot;instant_search_samsung&quot;,
+     &quot;parameters&quot;: SearchParameters {
+       &quot;disjunctiveFacets&quot;: Array [],
+       &quot;disjunctiveFacetsRefinements&quot;: Object {},
+       &quot;facets&quot;: Array [],
+       &quot;facetsExcludes&quot;: Object {},
+       &quot;facetsRefinements&quot;: Object {},
+       &quot;filters&quot;: &quot;brand:Samsung&quot;,
+       &quot;highlightPostTag&quot;: &quot;&lt;/cvi-highlight-0000000000&gt;&quot;,
+       &quot;highlightPreTag&quot;: &quot;&lt;cvi-highlight-0000000000&gt;&quot;,
        &quot;index&quot;: &quot;instant_search&quot;,
+       &quot;numericRefinements&quot;: Object {},
      },
    },
-   ObjectContaining {
+   Object {
      &quot;indexId&quot;: &quot;instant_search_apple&quot;,
-     &quot;parameters&quot;: ObjectContaining {
+     &quot;parameters&quot;: SearchParameters {
+       &quot;disjunctiveFacets&quot;: Array [],
+       &quot;disjunctiveFacetsRefinements&quot;: Object {},
+       &quot;facets&quot;: Array [],
+       &quot;facetsExcludes&quot;: Object {},
+       &quot;facetsRefinements&quot;: Object {},
        &quot;filters&quot;: &quot;brand:Apple&quot;,
+       &quot;highlightPostTag&quot;: &quot;&lt;/cvi-highlight-0000000000&gt;&quot;,
+       &quot;highlightPreTag&quot;: &quot;&lt;cvi-highlight-0000000000&gt;&quot;,
        &quot;index&quot;: &quot;instant_search&quot;,
+       &quot;numericRefinements&quot;: Object {},
      },
    },
-   ObjectContaining {
-     &quot;indexId&quot;: &quot;instant_search_samsung&quot;,
-     &quot;parameters&quot;: ObjectContaining {
-       &quot;filters&quot;: &quot;brand:Samsung&quot;,
+   Object {
+     &quot;indexId&quot;: &quot;instant_search&quot;,
+     &quot;parameters&quot;: SearchParameters {
+       &quot;disjunctiveFacets&quot;: Array [],
+       &quot;disjunctiveFacetsRefinements&quot;: Object {},
+       &quot;facets&quot;: Array [],
+       &quot;facetsExcludes&quot;: Object {},
+       &quot;facetsRefinements&quot;: Object {},
+       &quot;highlightPostTag&quot;: &quot;&lt;/cvi-highlight-0000000000&gt;&quot;,
+       &quot;highlightPreTag&quot;: &quot;&lt;cvi-highlight-0000000000&gt;&quot;,
        &quot;index&quot;: &quot;instant_search&quot;,
+       &quot;numericRefinements&quot;: Object {},
      },
    },
-   ObjectContaining {
-     &quot;indexId&quot;: &quot;instant_search_microsoft&quot;,
-     &quot;parameters&quot;: ObjectContaining {
-       &quot;filters&quot;: &quot;brand:Microsoft&quot;,
-       &quot;index&quot;: &quot;instant_search&quot;,
+   Object {
+     &quot;indexId&quot;: &quot;bestbuy&quot;,
+     &quot;parameters&quot;: SearchParameters {
+       &quot;disjunctiveFacets&quot;: Array [],
+       &quot;disjunctiveFacetsRefinements&quot;: Object {},
+       &quot;facets&quot;: Array [],
+       &quot;facetsExcludes&quot;: Object {},
+       &quot;facetsRefinements&quot;: Object {},
+       &quot;highlightPostTag&quot;: &quot;&lt;/cvi-highlight-0000000000&gt;&quot;,
+       &quot;highlightPreTag&quot;: &quot;&lt;cvi-highlight-0000000000&gt;&quot;,
+       &quot;index&quot;: &quot;bestbuy&quot;,
+       &quot;numericRefinements&quot;: Object {},
      },
    },
  ]
    at Object.&lt;anonymous&gt; (/Users/etienne/Projects/clinia-workspace/vizion/react-vizion/packages/react-vision-core/src/core/__tests__/createVisionManager.test.js:680:31)
    at Object.asyncJestTest (/Users/etienne/Projects/clinia-workspace/vizion/react-vizion/node_modules/jest-jasmine2/build/jasmineAsyncInstall.js:102:37)
    at /Users/etienne/Projects/clinia-workspace/vizion/react-vizion/node_modules/jest-jasmine2/build/queueRunner.js:43:12
    at new Promise (&lt;anonymous&gt;)
    at mapper (/Users/etienne/Projects/clinia-workspace/vizion/react-vizion/node_modules/jest-jasmine2/build/queueRunner.js:26:19)
    at /Users/etienne/Projects/clinia-workspace/vizion/react-vizion/node_modules/jest-jasmine2/build/queueRunner.js:73:41</failure>
    </testcase>
    <testcase classname="searchStalled should be updated if search is stalled" name="searchStalled should be updated if search is stalled" time="0.002">
    </testcase>
    <testcase classname="client.search should be called when there is a new widget" name="client.search should be called when there is a new widget" time="0.007">
    </testcase>
    <testcase classname="client.search should be called when there is a new client" name="client.search should be called when there is a new client" time="0.001">
    </testcase>
    <testcase classname="client.search should not be called when the search is skipped" name="client.search should not be called when the search is skipped" time="0.005">
    </testcase>
  </testsuite>
  <testsuite name="Pagination" errors="0" failures="0" skipped="0" timestamp="2020-04-17T22:59:53" time="8.943" tests="18">
    <testcase classname="Pagination applies its default props" name="Pagination applies its default props" time="0.131">
    </testcase>
    <testcase classname="Pagination applies its default props without refinement" name="Pagination applies its default props without refinement" time="0.003">
    </testcase>
    <testcase classname="Pagination applies its default props with custom className" name="Pagination applies its default props with custom className" time="0.003">
    </testcase>
    <testcase classname="Pagination displays the correct padding of links" name="Pagination displays the correct padding of links" time="0.079">
    </testcase>
    <testcase classname="Pagination allows toggling display of the first page button on and off" name="Pagination allows toggling display of the first page button on and off" time="0.006">
    </testcase>
    <testcase classname="Pagination indicates when first button is relevant" name="Pagination indicates when first button is relevant" time="0.016">
    </testcase>
    <testcase classname="Pagination allows toggling display of the last page button on and off" name="Pagination allows toggling display of the last page button on and off" time="0.074">
    </testcase>
    <testcase classname="Pagination allows toggling display of the previous page button on and off" name="Pagination allows toggling display of the previous page button on and off" time="0.004">
    </testcase>
    <testcase classname="Pagination allows toggling display of the next page button on and off" name="Pagination allows toggling display of the next page button on and off" time="0.004">
    </testcase>
    <testcase classname="Pagination lets you force a maximum of pages" name="Pagination lets you force a maximum of pages" time="0.022">
    </testcase>
    <testcase classname="Pagination lets you customize its theme" name="Pagination lets you customize its theme" time="0.003">
    </testcase>
    <testcase classname="Pagination lets you customize its translations" name="Pagination lets you customize its translations" time="0.009">
    </testcase>
    <testcase classname="Pagination disabled all button if no results" name="Pagination disabled all button if no results" time="0.002">
    </testcase>
    <testcase classname="Pagination refines its value when clicking on a page link" name="Pagination refines its value when clicking on a page link" time="0.485">
    </testcase>
    <testcase classname="Pagination ignores special clicks" name="Pagination ignores special clicks" time="0.076">
    </testcase>
    <testcase classname="Pagination padding behaviour should be adjusted when currentPage &lt; padding (at the very beginning)" name="Pagination padding behaviour should be adjusted when currentPage &lt; padding (at the very beginning)" time="0.059">
    </testcase>
    <testcase classname="Pagination padding behaviour should be adjusted when currentPage &lt; totalPages - padding (at the end)" name="Pagination padding behaviour should be adjusted when currentPage &lt; totalPages - padding (at the end)" time="0.016">
    </testcase>
    <testcase classname="Pagination padding behaviour should render the correct padding in every other case" name="Pagination padding behaviour should render the correct padding in every other case" time="0.1">
    </testcase>
  </testsuite>
  <testsuite name="Highlight" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:01" time="1.032" tests="3">
    <testcase classname="Highlight parses an highlighted property of hit object" name="Highlight parses an highlighted property of hit object" time="0.003">
    </testcase>
    <testcase classname="Highlight renders a hit with a custom tag correctly" name="Highlight renders a hit with a custom tag correctly" time="0.108">
    </testcase>
    <testcase classname="Highlight renders a hit with a custom className" name="Highlight renders a hit with a custom className" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="Vision" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:01" time="1.846" tests="5">
    <testcase classname="Vision validates its props" name="Vision validates its props" time="0.344">
    </testcase>
    <testcase classname="Vision correctly instantiates the visionManager" name="Vision correctly instantiates the visionManager" time="0.189">
    </testcase>
    <testcase classname="Vision updates Clinia client when new one is given in props" name="Vision updates Clinia client when new one is given in props" time="0.006">
    </testcase>
    <testcase classname="Vision createHrefForState passes through to createURL when it is defined" name="Vision createHrefForState passes through to createURL when it is defined" time="0.01">
    </testcase>
    <testcase classname="Vision createHrefForState returns # otherwise" name="Vision createHrefForState returns # otherwise" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="SearchBox" errors="0" failures="0" skipped="0" timestamp="2020-04-17T22:59:53" time="10.009" tests="18">
    <testcase classname="SearchBox applies its default props" name="SearchBox applies its default props" time="0.045">
    </testcase>
    <testcase classname="SearchBox applies its default props with custom className" name="SearchBox applies its default props with custom className" time="0.004">
    </testcase>
    <testcase classname="SearchBox transfers the autoFocus prop to the underlying input element" name="SearchBox transfers the autoFocus prop to the underlying input element" time="0.002">
    </testcase>
    <testcase classname="SearchBox treats its query prop as its input value" name="SearchBox treats its query prop as its input value" time="0.004">
    </testcase>
    <testcase classname="SearchBox lets you customize its theme" name="SearchBox lets you customize its theme" time="0.001">
    </testcase>
    <testcase classname="SearchBox lets you give custom components for reset and submit" name="SearchBox lets you give custom components for reset and submit" time="0.002">
    </testcase>
    <testcase classname="SearchBox lets you customize its translations" name="SearchBox lets you customize its translations" time="0.008">
    </testcase>
    <testcase classname="SearchBox treats query as a default value when searchAsYouType=false" name="SearchBox treats query as a default value when searchAsYouType=false" time="0.181">
    </testcase>
    <testcase classname="SearchBox refines its value on change when searchAsYouType=true" name="SearchBox refines its value on change when searchAsYouType=true" time="0.146">
    </testcase>
    <testcase classname="SearchBox only refines its query on submit when searchAsYouType=false" name="SearchBox only refines its query on submit when searchAsYouType=false" time="0.043">
    </testcase>
    <testcase classname="SearchBox onSubmit behavior should be override if provided as props" name="SearchBox onSubmit behavior should be override if provided as props" time="0.043">
    </testcase>
    <testcase classname="SearchBox focuses the input when one of the keys in focusShortcuts is pressed" name="SearchBox focuses the input when one of the keys in focusShortcuts is pressed" time="0.06">
    </testcase>
    <testcase classname="SearchBox should accept `onXXX` events" name="SearchBox should accept `onXXX` events" time="0.016">
    </testcase>
    <testcase classname="SearchBox should render the loader if showLoadingIndicator is true" name="SearchBox should render the loader if showLoadingIndicator is true" time="0.003">
    </testcase>
    <testcase classname="SearchBox expect to clear the query when the form is reset with searchAsYouType=true" name="SearchBox expect to clear the query when the form is reset with searchAsYouType=true" time="0.069">
    </testcase>
    <testcase classname="SearchBox expect to clear the query when the form is reset with searchAsYouType=false" name="SearchBox expect to clear the query when the form is reset with searchAsYouType=false" time="0.004">
    </testcase>
    <testcase classname="SearchBox should point created refs to its input element" name="SearchBox should point created refs to its input element" time="0.004">
    </testcase>
    <testcase classname="SearchBox should return a ref when given a callback" name="SearchBox should return a ref when given a callback" time="0.094">
    </testcase>
  </testsuite>
  <testsuite name="utils" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:02" time="1.178" tests="14">
    <testcase classname="utils createClassNames expect to return classNames" name="utils createClassNames expect to return classNames" time="0.001">
    </testcase>
    <testcase classname="utils createClassNames expect to return classNames with custom prefix" name="utils createClassNames expect to return classNames with custom prefix" time="0">
    </testcase>
    <testcase classname="utils isSpecialClick returns true if a modifier key is pressed" name="utils isSpecialClick returns true if a modifier key is pressed" time="0.001">
    </testcase>
    <testcase classname="utils isSpecialClick returns true if it&apos;s a middle click" name="utils isSpecialClick returns true if it&apos;s a middle click" time="0">
    </testcase>
    <testcase classname="utils isSpecialClick returns false otherwise" name="utils isSpecialClick returns false otherwise" time="0">
    </testcase>
    <testcase classname="utils capitalize capitalizes a string" name="utils capitalize capitalizes a string" time="0.001">
    </testcase>
    <testcase classname="utils capitalize works with empty strings" name="utils capitalize works with empty strings" time="0">
    </testcase>
    <testcase classname="utils range with end" name="utils range with end" time="0.141">
    </testcase>
    <testcase classname="utils range with start and end" name="utils range with start and end" time="0">
    </testcase>
    <testcase classname="utils range with end and step" name="utils range with end and step" time="0.001">
    </testcase>
    <testcase classname="utils range rounds decimal array lengths" name="utils range rounds decimal array lengths" time="0">
    </testcase>
    <testcase classname="utils find returns the first match based on the comparator" name="utils find returns the first match based on the comparator" time="0.001">
    </testcase>
    <testcase classname="utils find returns undefined in non-found cases" name="utils find returns undefined in non-found cases" time="0.018">
    </testcase>
    <testcase classname="utils extractInputEventsFromProps should return all events except the internal ones" name="utils extractInputEventsFromProps should return all events except the internal ones" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="getInsightsAnonymousUserToken" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:02" time="1.303" tests="4">
    <testcase classname="getInsightsAnonymousUserToken should return undefined when no cookies" name="getInsightsAnonymousUserToken should return undefined when no cookies" time="0.178">
    </testcase>
    <testcase classname="getInsightsAnonymousUserToken should return undefined when cookie present but expired" name="getInsightsAnonymousUserToken should return undefined when cookie present but expired" time="0.007">
    </testcase>
    <testcase classname="getInsightsAnonymousUserToken should return the anonymous uuid when cookie present and valid" name="getInsightsAnonymousUserToken should return the anonymous uuid when cookie present and valid" time="0.038">
    </testcase>
    <testcase classname="getInsightsAnonymousUserToken should return the anonymous uuid when other cookies are invalid" name="getInsightsAnonymousUserToken should return the anonymous uuid when other cookies are invalid" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="connectGeoSearch" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:01" time="1.809" tests="53">
    <testcase classname="connectGeoSearch single index getProvidedProps expect to return default provided props" name="connectGeoSearch single index getProvidedProps expect to return default provided props" time="0.002">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps hits expect to return hits when we hare results" name="connectGeoSearch single index getProvidedProps hits expect to return hits when we hare results" time="0.077">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps hits expect to return hits with only &quot;_geoPoint&quot; when we have results" name="connectGeoSearch single index getProvidedProps hits expect to return hits with only &quot;_geoPoint&quot; when we have results" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps hits expect to return empty hits when we don&apos;t have results" name="connectGeoSearch single index getProvidedProps hits expect to return empty hits when we don&apos;t have results" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps position expect to return the position from the searchState (aroundLatLng)" name="connectGeoSearch single index getProvidedProps position expect to return the position from the searchState (aroundLatLng)" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps position expect to return the position from the searchState (configure.aroundLatLng)" name="connectGeoSearch single index getProvidedProps position expect to return the position from the searchState (configure.aroundLatLng)" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps position expect to return the position from the SearchResults" name="connectGeoSearch single index getProvidedProps position expect to return the position from the SearchResults" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps position expect to return undefined from an empty searchState" name="connectGeoSearch single index getProvidedProps position expect to return undefined from an empty searchState" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps position expect to return undefined with the default refinement" name="connectGeoSearch single index getProvidedProps position expect to return undefined with the default refinement" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps currentRefinement expect to return the boundingBox from the searchState" name="connectGeoSearch single index getProvidedProps currentRefinement expect to return the boundingBox from the searchState" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps currentRefinement expect to return the boundingBox from the SearchResults" name="connectGeoSearch single index getProvidedProps currentRefinement expect to return the boundingBox from the SearchResults" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps currentRefinement expect to return the default refinement" name="connectGeoSearch single index getProvidedProps currentRefinement expect to return the default refinement" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps currentRefinement expect to return undefined from an empty searchState" name="connectGeoSearch single index getProvidedProps currentRefinement expect to return undefined from an empty searchState" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchState)" name="connectGeoSearch single index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchState)" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchParameters)" name="connectGeoSearch single index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchParameters)" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getProvidedProps isRefinedWithMap expect to return false when it&apos;s not refined with the map" name="connectGeoSearch single index getProvidedProps isRefinedWithMap expect to return false when it&apos;s not refined with the map" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index refine expect to set the boundingBox when boundingBox is provided" name="connectGeoSearch single index refine expect to set the boundingBox when boundingBox is provided" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index refine expect to replace the previous value when boundingBox is provided" name="connectGeoSearch single index refine expect to replace the previous value when boundingBox is provided" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index refine expect to clear the previous value when boundingBox is omit" name="connectGeoSearch single index refine expect to clear the previous value when boundingBox is omit" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getSearchParameters expect to set the parameter &quot;insideBoundingBox&quot; when boundingBox is provided" name="connectGeoSearch single index getSearchParameters expect to set the parameter &quot;insideBoundingBox&quot; when boundingBox is provided" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getSearchParameters expect to return the given searchParameters when boundingBox is omit" name="connectGeoSearch single index getSearchParameters expect to return the given searchParameters when boundingBox is omit" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index cleanUp expect to remove the refinement from the searchState when boundingBox is provided" name="connectGeoSearch single index cleanUp expect to remove the refinement from the searchState when boundingBox is provided" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index cleanUp expect to return the given searchState when boundingBox is omit" name="connectGeoSearch single index cleanUp expect to return the given searchState when boundingBox is omit" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getMetadata expect to return the meta when boundingBox is provided" name="connectGeoSearch single index getMetadata expect to return the meta when boundingBox is provided" time="0">
    </testcase>
    <testcase classname="connectGeoSearch single index getMetadata expect to return an empty meta when boundingBox is omit" name="connectGeoSearch single index getMetadata expect to return an empty meta when boundingBox is omit" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch single index getMetadata expect to clear the boundingBox when value is called" name="connectGeoSearch single index getMetadata expect to clear the boundingBox when value is called" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps expect to return default provided props" name="connectGeoSearch multi index getProvidedProps expect to return default provided props" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps hits expect to return hits when we have results" name="connectGeoSearch multi index getProvidedProps hits expect to return hits when we have results" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps hits expect to return hits with only &quot;_geoPoint&quot; when we have results" name="connectGeoSearch multi index getProvidedProps hits expect to return hits with only &quot;_geoPoint&quot; when we have results" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps hits expect to return empty hits when we don&apos;t have results" name="connectGeoSearch multi index getProvidedProps hits expect to return empty hits when we don&apos;t have results" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps position expect to return the position from the searchState (aroundLatLng)" name="connectGeoSearch multi index getProvidedProps position expect to return the position from the searchState (aroundLatLng)" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps position expect to return the position from the searchState (configure.aroungLatLng)" name="connectGeoSearch multi index getProvidedProps position expect to return the position from the searchState (configure.aroungLatLng)" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps position expect to return undefined from an empty searchState" name="connectGeoSearch multi index getProvidedProps position expect to return undefined from an empty searchState" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps position expect to return undefined with the default refinement" name="connectGeoSearch multi index getProvidedProps position expect to return undefined with the default refinement" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the boundingBox from the searchState" name="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the boundingBox from the searchState" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the boundingBox from the searchState with string values" name="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the boundingBox from the searchState with string values" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the boundingBox from the SearchResults" name="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the boundingBox from the SearchResults" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the default refinement" name="connectGeoSearch multi index getProvidedProps currentRefinement expect to return the default refinement" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps currentRefinement expect to return an undefined from an empty searchState" name="connectGeoSearch multi index getProvidedProps currentRefinement expect to return an undefined from an empty searchState" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchState)" name="connectGeoSearch multi index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchState)" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchParameters)" name="connectGeoSearch multi index getProvidedProps isRefinedWithMap expect to return true when it&apos;s refined with the map (from the searchParameters)" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps isRefinedWithMap expect to return false when it&apos;s not refined with the map" name="connectGeoSearch multi index getProvidedProps isRefinedWithMap expect to return false when it&apos;s not refined with the map" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps refine expect to set the boundingBox when boundingBox is provided" name="connectGeoSearch multi index getProvidedProps refine expect to set the boundingBox when boundingBox is provided" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps refine expect to replace the previous value when boundingBox is provided" name="connectGeoSearch multi index getProvidedProps refine expect to replace the previous value when boundingBox is provided" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps refine expect to clear the previous value when boundingBox is omit" name="connectGeoSearch multi index getProvidedProps refine expect to clear the previous value when boundingBox is omit" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps getSearchParameters expect to set the parameter &quot;insideBoundingBox&quot; when boundingBox is provided" name="connectGeoSearch multi index getProvidedProps getSearchParameters expect to set the parameter &quot;insideBoundingBox&quot; when boundingBox is provided" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps getSearchParameters expect to return the given searchParameters when boundingBox is omit" name="connectGeoSearch multi index getProvidedProps getSearchParameters expect to return the given searchParameters when boundingBox is omit" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps cleanUp expect to remove the refinement from the searchState when boundingBox is provided" name="connectGeoSearch multi index getProvidedProps cleanUp expect to remove the refinement from the searchState when boundingBox is provided" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps cleanUp expect to return the given searchState when boundingBox is omit" name="connectGeoSearch multi index getProvidedProps cleanUp expect to return the given searchState when boundingBox is omit" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps getMetadata expect to return the meta when boundingBox is provided" name="connectGeoSearch multi index getProvidedProps getMetadata expect to return the meta when boundingBox is provided" time="0.001">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps getMetadata expect to return an empty meta when boundingBox is omit" name="connectGeoSearch multi index getProvidedProps getMetadata expect to return an empty meta when boundingBox is omit" time="0">
    </testcase>
    <testcase classname="connectGeoSearch multi index getProvidedProps getMetadata expect to clear the boundingBox when value is called" name="connectGeoSearch multi index getProvidedProps getMetadata expect to clear the boundingBox when value is called" time="0">
    </testcase>
    <testcase classname="connectGeoSearch shouldComponentUpdate expect to always return true" name="connectGeoSearch shouldComponentUpdate expect to always return true" time="0">
    </testcase>
  </testsuite>
  <testsuite name="ClearRefinements" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:02" time="1.631" tests="5">
    <testcase classname="ClearRefinements renders a clickable button" name="ClearRefinements renders a clickable button" time="0.002">
    </testcase>
    <testcase classname="ClearRefinements renders a clickable button with a custom className" name="ClearRefinements renders a clickable button with a custom className" time="0.095">
    </testcase>
    <testcase classname="ClearRefinements has a disabled mode" name="ClearRefinements has a disabled mode" time="0.027">
    </testcase>
    <testcase classname="ClearRefinements is disabled when there is no filters" name="ClearRefinements is disabled when there is no filters" time="0.048">
    </testcase>
    <testcase classname="ClearRefinements is not disabled when there are filters" name="ClearRefinements is not disabled when there are filters" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="Index" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:02" time="1.423" tests="8">
    <testcase classname="Index registers itself on mount" name="Index registers itself on mount" time="0.009">
    </testcase>
    <testcase classname="Index calls onSearchParameters on mount" name="Index calls onSearchParameters on mount" time="0.001">
    </testcase>
    <testcase classname="Index calls update if indexName props changes" name="Index calls update if indexName props changes" time="0.2">
    </testcase>
    <testcase classname="Index unregisters itself on unmount" name="Index unregisters itself on unmount" time="0.004">
    </testcase>
    <testcase classname="Index exposes multi index context" name="Index exposes multi index context" time="0.045">
    </testcase>
    <testcase classname="Index provides search parameters from instance props" name="Index provides search parameters from instance props" time="0.001">
    </testcase>
    <testcase classname="Index provides search parameters from argument props when instance props are not available" name="Index provides search parameters from argument props when instance props are not available" time="0.001">
    </testcase>
    <testcase classname="Index wrapped with VisionProvider: sets correct props" name="Index wrapped with VisionProvider: sets correct props" time="0.004">
    </testcase>
  </testsuite>
  <testsuite name="connectPagination" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:03" time="0.983" tests="10">
    <testcase classname="connectPagination single index provides the correct props to the component" name="connectPagination single index provides the correct props to the component" time="0.002">
    </testcase>
    <testcase classname="connectPagination single index doesn&apos;t render when no results are available" name="connectPagination single index doesn&apos;t render when no results are available" time="0">
    </testcase>
    <testcase classname="connectPagination single index calling refine updates the widget&apos;s search state" name="connectPagination single index calling refine updates the widget&apos;s search state" time="0">
    </testcase>
    <testcase classname="connectPagination single index refines the page parameter" name="connectPagination single index refines the page parameter" time="0.001">
    </testcase>
    <testcase classname="connectPagination single index registers its id in metadata" name="connectPagination single index registers its id in metadata" time="0">
    </testcase>
    <testcase classname="connectPagination single index should return the right searchState when clean up" name="connectPagination single index should return the right searchState when clean up" time="0.001">
    </testcase>
    <testcase classname="connectPagination multi index provides the correct props to the component" name="connectPagination multi index provides the correct props to the component" time="0">
    </testcase>
    <testcase classname="connectPagination multi index calling refine updates the widget&apos;s search state" name="connectPagination multi index calling refine updates the widget&apos;s search state" time="0.001">
    </testcase>
    <testcase classname="connectPagination multi index refines the page parameter" name="connectPagination multi index refines the page parameter" time="0">
    </testcase>
    <testcase classname="connectPagination multi index should return the right searchState when clean up" name="connectPagination multi index should return the right searchState when clean up" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="connectSearchBox" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:03" time="1.054" tests="10">
    <testcase classname="connectSearchBox single index provides the correct props to the component" name="connectSearchBox single index provides the correct props to the component" time="0.001">
    </testcase>
    <testcase classname="connectSearchBox single index calling refine updates the widget&apos;s search state" name="connectSearchBox single index calling refine updates the widget&apos;s search state" time="0.025">
    </testcase>
    <testcase classname="connectSearchBox single index supports defaultRefinement" name="connectSearchBox single index supports defaultRefinement" time="0">
    </testcase>
    <testcase classname="connectSearchBox single index refines the query parameter" name="connectSearchBox single index refines the query parameter" time="0">
    </testcase>
    <testcase classname="connectSearchBox single index should return the right searchState when clean up" name="connectSearchBox single index should return the right searchState when clean up" time="0.001">
    </testcase>
    <testcase classname="connectSearchBox multi index provides the correct props to the component" name="connectSearchBox multi index provides the correct props to the component" time="0.002">
    </testcase>
    <testcase classname="connectSearchBox multi index calling refine updates the widget&apos;s search state" name="connectSearchBox multi index calling refine updates the widget&apos;s search state" time="0">
    </testcase>
    <testcase classname="connectSearchBox multi index supports defaultRefinement" name="connectSearchBox multi index supports defaultRefinement" time="0.001">
    </testcase>
    <testcase classname="connectSearchBox multi index refines the query parameter" name="connectSearchBox multi index refines the query parameter" time="0.001">
    </testcase>
    <testcase classname="connectSearchBox multi index should return the right searchState when clean up" name="connectSearchBox multi index should return the right searchState when clean up" time="0">
    </testcase>
  </testsuite>
  <testsuite name="CurrentRefinements" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:03" time="1.417" tests="7">
    <testcase classname="CurrentRefinements expect to render a list of current refinements" name="CurrentRefinements expect to render a list of current refinements" time="0.006">
    </testcase>
    <testcase classname="CurrentRefinements expect to render a list without refinements" name="CurrentRefinements expect to render a list without refinements" time="0.001">
    </testcase>
    <testcase classname="CurrentRefinements expect to render a list with a custom className" name="CurrentRefinements expect to render a list with a custom className" time="0.001">
    </testcase>
    <testcase classname="CurrentRefinements expect to refine the &quot;color&quot; onClick" name="CurrentRefinements expect to refine the &quot;color&quot; onClick" time="0.004">
    </testcase>
    <testcase classname="CurrentRefinements expect to refine the &quot;category: iPad&quot; onClick" name="CurrentRefinements expect to refine the &quot;category: iPad&quot; onClick" time="0.002">
    </testcase>
    <testcase classname="CurrentRefinements - Connected expect to render a list of current refinements" name="CurrentRefinements - Connected expect to render a list of current refinements" time="0.133">
    </testcase>
    <testcase classname="CurrentRefinements - Connected expect to render a list of current refinements with custom translations" name="CurrentRefinements - Connected expect to render a list of current refinements with custom translations" time="0.039">
    </testcase>
  </testsuite>
  <testsuite name="Hits" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:03" time="1.012" tests="2">
    <testcase classname="Hits accepts a hitComponent prop" name="Hits accepts a hitComponent prop" time="0.003">
    </testcase>
    <testcase classname="Hits accepts a custom className" name="Hits accepts a custom className" time="0.126">
    </testcase>
  </testsuite>
  <testsuite name="createVisionManager with multi index" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:03" time="1.336" tests="5">
    <testcase classname="createVisionManager with multi index updates the store and searches" name="createVisionManager with multi index updates the store and searches" time="0.007">
    </testcase>
    <testcase classname="createVisionManager with multi index searches with duplicate Index &amp; SortBy" name="createVisionManager with multi index searches with duplicate Index &amp; SortBy" time="0.052">
    </testcase>
    <testcase classname="createVisionManager with multi index searches with N queries for N Index widgets" name="createVisionManager with multi index searches with N queries for N Index widgets" time="0.007">
    </testcase>
    <testcase classname="createVisionManager with multi index searches with same index but different params" name="createVisionManager with multi index searches with same index but different params" time="0.019">
    </testcase>
    <testcase classname="createVisionManager with multi index switching from mono to multi index" name="createVisionManager with multi index switching from mono to multi index" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="connectInfiniteHits" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:03" time="1.669" tests="19">
    <testcase classname="connectInfiniteHits single index provides the current hits to the component" name="connectInfiniteHits single index provides the current hits to the component" time="0.001">
    </testcase>
    <testcase classname="connectInfiniteHits single index accumulate hits internally" name="connectInfiniteHits single index accumulate hits internally" time="0.089">
    </testcase>
    <testcase classname="connectInfiniteHits single index prepend hits internally" name="connectInfiniteHits single index prepend hits internally" time="0.002">
    </testcase>
    <testcase classname="connectInfiniteHits single index accumulate hits internally while changing perPage configuration" name="connectInfiniteHits single index accumulate hits internally while changing perPage configuration" time="0.011">
    </testcase>
    <testcase classname="connectInfiniteHits single index should not reset while accumulating results" name="connectInfiniteHits single index should not reset while accumulating results" time="0.014">
    </testcase>
    <testcase classname="connectInfiniteHits single index Indicates the last page after several pages" name="connectInfiniteHits single index Indicates the last page after several pages" time="0.135">
    </testcase>
    <testcase classname="connectInfiniteHits single index calls refine with next page when calling refineNext" name="connectInfiniteHits single index calls refine with next page when calling refineNext" time="0.001">
    </testcase>
    <testcase classname="connectInfiniteHits single index calls refine with previous page when calling refinePrevious" name="connectInfiniteHits single index calls refine with previous page when calling refinePrevious" time="0">
    </testcase>
    <testcase classname="connectInfiniteHits single index adds 1 to page when calling refine" name="connectInfiniteHits single index adds 1 to page when calling refine" time="0.001">
    </testcase>
    <testcase classname="connectInfiniteHits single index set page to the corresponding index" name="connectInfiniteHits single index set page to the corresponding index" time="0">
    </testcase>
    <testcase classname="connectInfiniteHits single index automatically converts String state to Number" name="connectInfiniteHits single index automatically converts String state to Number" time="0">
    </testcase>
    <testcase classname="connectInfiniteHits single index expect to always return an array of hits" name="connectInfiniteHits single index expect to always return an array of hits" time="0">
    </testcase>
    <testcase classname="connectInfiniteHits multi index provides the current hits to the component" name="connectInfiniteHits multi index provides the current hits to the component" time="0">
    </testcase>
    <testcase classname="connectInfiniteHits multi index accumulate hits internally" name="connectInfiniteHits multi index accumulate hits internally" time="0.001">
    </testcase>
    <testcase classname="connectInfiniteHits multi index prepend hits internally" name="connectInfiniteHits multi index prepend hits internally" time="0">
    </testcase>
    <testcase classname="connectInfiniteHits multi index accumulate hits internally while changing perPage configuration" name="connectInfiniteHits multi index accumulate hits internally while changing perPage configuration" time="0.002">
    </testcase>
    <testcase classname="connectInfiniteHits multi index should not accumulate hits internally while changing query" name="connectInfiniteHits multi index should not accumulate hits internally while changing query" time="0">
    </testcase>
    <testcase classname="connectInfiniteHits multi index should not reset while accumulating results" name="connectInfiniteHits multi index should not reset while accumulating results" time="0.306">
    </testcase>
    <testcase classname="connectInfiniteHits multi index Indicates the last page after several pages" name="connectInfiniteHits multi index Indicates the last page after several pages" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="utility method for manipulating the search state" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:04" time="1.391" tests="16">
    <testcase classname="utility method for manipulating the search state when there is a single index refine with no namespace" name="utility method for manipulating the search state when there is a single index refine with no namespace" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there is a single index refine with namespace" name="utility method for manipulating the search state when there is a single index refine with namespace" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there is a single index getCurrentRefinementValue retrieves the current refinement value" name="utility method for manipulating the search state when there is a single index getCurrentRefinementValue retrieves the current refinement value" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there is a single index getCurrentRefinementValue retrieves default value" name="utility method for manipulating the search state when there is a single index getCurrentRefinementValue retrieves default value" time="0">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there is a single index getCurrentRefinementValue retrieves from objects without prototype" name="utility method for manipulating the search state when there is a single index getCurrentRefinementValue retrieves from objects without prototype" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there is a single index clean up values" name="utility method for manipulating the search state when there is a single index clean up values" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there is a single index get results" name="utility method for manipulating the search state when there is a single index get results" time="0">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index refine with no namespace" name="utility method for manipulating the search state when there are multiple index refine with no namespace" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index refine with namespace" name="utility method for manipulating the search state when there are multiple index refine with namespace" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index getCurrentRefinementValue retrieves the current refinement value" name="utility method for manipulating the search state when there are multiple index getCurrentRefinementValue retrieves the current refinement value" time="0.125">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index getCurrentRefinementValue retrieves default value" name="utility method for manipulating the search state when there are multiple index getCurrentRefinementValue retrieves default value" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index getCurrentRefinementValue retrieves from objects without prototype" name="utility method for manipulating the search state when there are multiple index getCurrentRefinementValue retrieves from objects without prototype" time="0.004">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index clean up values" name="utility method for manipulating the search state when there are multiple index clean up values" time="0.005">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index get results" name="utility method for manipulating the search state when there are multiple index get results" time="0.001">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index refine shared widgets should reset indices page to 1 with resetPage" name="utility method for manipulating the search state when there are multiple index refine shared widgets should reset indices page to 1 with resetPage" time="0">
    </testcase>
    <testcase classname="utility method for manipulating the search state when there are multiple index refine shared widgets should not reset indices page to 1 without resetPage" name="utility method for manipulating the search state when there are multiple index refine shared widgets should not reset indices page to 1 without resetPage" time="0">
    </testcase>
  </testsuite>
  <testsuite name="createVisionManager with results" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:04" time="1.15" tests="2">
    <testcase classname="createVisionManager with results on search updates the store on widget lifecycle" name="createVisionManager with results on search updates the store on widget lifecycle" time="0.011">
    </testcase>
    <testcase classname="createVisionManager with results on search updates the store on external updates" name="createVisionManager with results on search updates the store on external updates" time="0.01">
    </testcase>
  </testsuite>
  <testsuite name="utils" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:04" time="1.691" tests="20">
    <testcase classname="utils getDisplayName gets the right displayName from classes" name="utils getDisplayName gets the right displayName from classes" time="0.001">
    </testcase>
    <testcase classname="utils getDisplayName gets the right displayName from stateless components" name="utils getDisplayName gets the right displayName from stateless components" time="0.001">
    </testcase>
    <testcase classname="utils getDisplayName sets a default displayName when not able to find one" name="utils getDisplayName sets a default displayName when not able to find one" time="0">
    </testcase>
    <testcase classname="utils defer calling a function asynchronously, should be done as soon as possible." name="utils defer calling a function asynchronously, should be done as soon as possible." time="0">
    </testcase>
    <testcase classname="utils remove empty key empty key should be removed" name="utils remove empty key empty key should be removed" time="0.001">
    </testcase>
    <testcase classname="utils remove empty key does not do anything on empty root" name="utils remove empty key does not do anything on empty root" time="0.001">
    </testcase>
    <testcase classname="utils remove empty key does empty out objects" name="utils remove empty key does empty out objects" time="0">
    </testcase>
    <testcase classname="utils remove empty key does not empty out arrays" name="utils remove empty key does not empty out arrays" time="0">
    </testcase>
    <testcase classname="utils addAbsolutePositions should add __positions 1 and 2 on page 0" name="utils addAbsolutePositions should add __positions 1 and 2 on page 0" time="0">
    </testcase>
    <testcase classname="utils addAbsolutePositions should add __positions 5 and 6 on page 2" name="utils addAbsolutePositions should add __positions 5 and 6 on page 2" time="0.001">
    </testcase>
    <testcase classname="utils addQueryID should passed __queryID to hits" name="utils addQueryID should passed __queryID to hits" time="0.001">
    </testcase>
    <testcase classname="utils getPropertyByPath returns undefined on non-object root" name="utils getPropertyByPath returns undefined on non-object root" time="0">
    </testcase>
    <testcase classname="utils getPropertyByPath returns path if exists" name="utils getPropertyByPath returns path if exists" time="0.001">
    </testcase>
    <testcase classname="utils getPropertyByPath accepts a pre-split path as array" name="utils getPropertyByPath accepts a pre-split path as array" time="0.004">
    </testcase>
    <testcase classname="utils getPropertyByPath does not split a pre-split path as array" name="utils getPropertyByPath does not split a pre-split path as array" time="0">
    </testcase>
    <testcase classname="utils getPropertyByPath returns undefined if does not exist" name="utils getPropertyByPath returns undefined if does not exist" time="0.001">
    </testcase>
    <testcase classname="utils getPropertyByPath returns indexed path if exists" name="utils getPropertyByPath returns indexed path if exists" time="0.001">
    </testcase>
    <testcase classname="utils getPropertyByPath returns undefined if indexed path does not exist" name="utils getPropertyByPath returns undefined if indexed path does not exist" time="0">
    </testcase>
    <testcase classname="utils find returns the first match based on the comparator" name="utils find returns the first match based on the comparator" time="0">
    </testcase>
    <testcase classname="utils find returns undefined in non-found cases" name="utils find returns undefined in non-found cases" time="0.007">
    </testcase>
  </testsuite>
  <testsuite name="connectConfigure" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:04" time="1.309" tests="6">
    <testcase classname="connectConfigure single index propagates the props to the SearchParameters without children &amp; contextValue" name="connectConfigure single index propagates the props to the SearchParameters without children &amp; contextValue" time="0.001">
    </testcase>
    <testcase classname="connectConfigure single index calling transitionState should add configure parameters to the search state" name="connectConfigure single index calling transitionState should add configure parameters to the search state" time="0.001">
    </testcase>
    <testcase classname="connectConfigure single index calling cleanUp should remove configure parameters from the search state" name="connectConfigure single index calling cleanUp should remove configure parameters from the search state" time="0.001">
    </testcase>
    <testcase classname="connectConfigure multi index it propagates the props to the SearchParameters without children" name="connectConfigure multi index it propagates the props to the SearchParameters without children" time="0">
    </testcase>
    <testcase classname="connectConfigure multi index calling transitionState should add configure parameters to the search state" name="connectConfigure multi index calling transitionState should add configure parameters to the search state" time="0.212">
    </testcase>
    <testcase classname="connectConfigure multi index calling cleanUp should remove configure parameters from the search state" name="connectConfigure multi index calling cleanUp should remove configure parameters from the search state" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="connectCurrentRefinements" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:04" time="1.307" tests="6">
    <testcase classname="connectCurrentRefinements provides the correct props to the component" name="connectCurrentRefinements provides the correct props to the component" time="0.002">
    </testcase>
    <testcase classname="connectCurrentRefinements provides the query if clearsQuery props is true" name="connectCurrentRefinements provides the query if clearsQuery props is true" time="0">
    </testcase>
    <testcase classname="connectCurrentRefinements dont provide the query if clearsQuery props is true but the current refinement is an empty string" name="connectCurrentRefinements dont provide the query if clearsQuery props is true but the current refinement is an empty string" time="0.001">
    </testcase>
    <testcase classname="connectCurrentRefinements refine applies the selected filters clear method on searchState" name="connectCurrentRefinements refine applies the selected filters clear method on searchState" time="0.09">
    </testcase>
    <testcase classname="connectCurrentRefinements deduplicates entries with transformItems" name="connectCurrentRefinements deduplicates entries with transformItems" time="0.002">
    </testcase>
    <testcase classname="connectCurrentRefinements computes canRefine based on the length of the transformed items list" name="connectCurrentRefinements computes canRefine based on the length of the transformed items list" time="0">
    </testcase>
  </testsuite>
  <testsuite name="createHTMLMarker" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:04" time="1.615" tests="13">
    <testcase classname="createHTMLMarker expect to create a marker" name="createHTMLMarker expect to create a marker" time="0.005">
    </testcase>
    <testcase classname="createHTMLMarker expect to create a marker with a custom anchor" name="createHTMLMarker expect to create a marker with a custom anchor" time="0.079">
    </testcase>
    <testcase classname="createHTMLMarker expect to create a marker with a custom className" name="createHTMLMarker expect to create a marker with a custom className" time="0.001">
    </testcase>
    <testcase classname="createHTMLMarker onAdd expect to append the element to the overlay" name="createHTMLMarker onAdd expect to append the element to the overlay" time="0.015">
    </testcase>
    <testcase classname="createHTMLMarker onAdd expect to not append the element to the overlay when panes are not available" name="createHTMLMarker onAdd expect to not append the element to the overlay when panes are not available" time="0.001">
    </testcase>
    <testcase classname="createHTMLMarker draw expect to set the correct position on the element" name="createHTMLMarker draw expect to set the correct position on the element" time="0.002">
    </testcase>
    <testcase classname="createHTMLMarker draw expect to set the correct zIndex on the element" name="createHTMLMarker draw expect to set the correct zIndex on the element" time="0.001">
    </testcase>
    <testcase classname="createHTMLMarker draw expect to not set the correct position when the projection is not available" name="createHTMLMarker draw expect to not set the correct position when the projection is not available" time="0.001">
    </testcase>
    <testcase classname="createHTMLMarker onRemove expect to remove the element" name="createHTMLMarker onRemove expect to remove the element" time="0.003">
    </testcase>
    <testcase classname="createHTMLMarker onRemove expect to remove all the listeners" name="createHTMLMarker onRemove expect to remove all the listeners" time="0.006">
    </testcase>
    <testcase classname="createHTMLMarker addListener expect to register listener" name="createHTMLMarker addListener expect to register listener" time="0.001">
    </testcase>
    <testcase classname="createHTMLMarker addListener expect to return a function to remove the listener" name="createHTMLMarker addListener expect to return a function to remove the listener" time="0.001">
    </testcase>
    <testcase classname="createHTMLMarker getPosition expect to return the latLng" name="createHTMLMarker getPosition expect to return the latLng" time="0.002">
    </testcase>
  </testsuite>
  <testsuite name="parseCliniaHit()" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:05" time="1.244" tests="9">
    <testcase classname="parseCliniaHit() it does not break when there is a missing property" name="parseCliniaHit() it does not break when there is a missing property" time="0.008">
    </testcase>
    <testcase classname="parseCliniaHit() creates a single element when there is no tag" name="parseCliniaHit() creates a single element when there is no tag" time="0.001">
    </testcase>
    <testcase classname="parseCliniaHit() creates a single element when there is only a tag" name="parseCliniaHit() creates a single element when there is only a tag" time="0">
    </testcase>
    <testcase classname="parseCliniaHit() fetches and parses a deep property" name="parseCliniaHit() fetches and parses a deep property" time="0.001">
    </testcase>
    <testcase classname="parseCliniaHit() parses the string and returns the part that are highlighted - 1 big highlight" name="parseCliniaHit() parses the string and returns the part that are highlighted - 1 big highlight" time="0.003">
    </testcase>
    <testcase classname="parseCliniaHit() supports the array format, parses it and returns the part that is highlighted" name="parseCliniaHit() supports the array format, parses it and returns the part that is highlighted" time="0">
    </testcase>
    <testcase classname="parseCliniaHit() parses the string and returns the part that are highlighted - same pre and post tag" name="parseCliniaHit() parses the string and returns the part that are highlighted - same pre and post tag" time="0.001">
    </testcase>
    <testcase classname="parseCliniaHit() throws when hit is `null`" name="parseCliniaHit() throws when hit is `null`" time="0.084">
    </testcase>
    <testcase classname="parseCliniaHit() throws when hit is `undefined`" name="parseCliniaHit() throws when hit is `undefined`" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="createWidgetsManager" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:05" time="1.43" tests="4">
    <testcase classname="createWidgetsManager registerWidget adds the widget to the widgets list" name="createWidgetsManager registerWidget adds the widget to the widgets list" time="0.001">
    </testcase>
    <testcase classname="createWidgetsManager registerWidget returns an unregister method" name="createWidgetsManager registerWidget returns an unregister method" time="0">
    </testcase>
    <testcase classname="createWidgetsManager registerWidget schedules an update" name="createWidgetsManager registerWidget schedules an update" time="0.001">
    </testcase>
    <testcase classname="createWidgetsManager update schedules an update" name="createWidgetsManager update schedules an update" time="0.143">
    </testcase>
  </testsuite>
  <testsuite name="utils" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:06" time="1.027" tests="10">
    <testcase classname="utils registerEvents expect to add listeners from events" name="utils registerEvents expect to add listeners from events" time="0.001">
    </testcase>
    <testcase classname="utils registerEvents expect to add listeners with event &amp; marker" name="utils registerEvents expect to add listeners with event &amp; marker" time="0.001">
    </testcase>
    <testcase classname="utils registerEvents expect to only add listeners listed from events" name="utils registerEvents expect to only add listeners listed from events" time="0.001">
    </testcase>
    <testcase classname="utils registerEvents expect to only add listeners listed from props" name="utils registerEvents expect to only add listeners listed from props" time="0.023">
    </testcase>
    <testcase classname="utils registerEvents expect to return a function that remove the listeners" name="utils registerEvents expect to return a function that remove the listeners" time="0.001">
    </testcase>
    <testcase classname="utils createListenersPropTypes expect to return an object with listeners propType from event types" name="utils createListenersPropTypes expect to return an object with listeners propType from event types" time="0.001">
    </testcase>
    <testcase classname="utils createListenersPropTypes expect to return an empty object from empty event types" name="utils createListenersPropTypes expect to return an empty object from empty event types" time="0">
    </testcase>
    <testcase classname="utils createFilterProps expect to return an object without excluded keys" name="utils createFilterProps expect to return an object without excluded keys" time="0">
    </testcase>
    <testcase classname="utils createFilterProps expect to return the given props when excluded keys is empty" name="utils createFilterProps expect to return the given props when excluded keys is empty" time="0.001">
    </testcase>
    <testcase classname="utils createFilterProps expect to return an empty object when all keys are excluded" name="utils createFilterProps expect to return an empty object when all keys are excluded" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="translatable" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:05" time="1.393" tests="2">
    <testcase classname="translatable provides a translate prop to the composed component" name="translatable provides a translate prop to the composed component" time="0.135">
    </testcase>
    <testcase classname="translatable uses the translations passed as props before the default" name="translatable uses the translations passed as props before the default" time="0.008">
    </testcase>
  </testsuite>
  <testsuite name="createVisionManager with errors" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:06" time="1.048" tests="3">
    <testcase classname="createVisionManager with errors on search updates the store on widget lifecycle" name="createVisionManager with errors on search updates the store on widget lifecycle" time="0.007">
    </testcase>
    <testcase classname="createVisionManager with errors on search updates the store on external updates" name="createVisionManager with errors on search updates the store on external updates" time="0.002">
    </testcase>
    <testcase classname="createVisionManager with errors on search reset the error after a successful search" name="createVisionManager with errors on search reset the error after a successful search" time="0.003">
    </testcase>
  </testsuite>
  <testsuite name="GoogleMapsLoader" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:06" time="1.201" tests="6">
    <testcase classname="GoogleMapsLoader expect to call Google Maps API" name="GoogleMapsLoader expect to call Google Maps API" time="0.003">
    </testcase>
    <testcase classname="GoogleMapsLoader expect to call Google Maps API with a custom API Key" name="GoogleMapsLoader expect to call Google Maps API with a custom API Key" time="0.001">
    </testcase>
    <testcase classname="GoogleMapsLoader expect to call Google Maps API with a custom endpoint" name="GoogleMapsLoader expect to call Google Maps API with a custom endpoint" time="0.001">
    </testcase>
    <testcase classname="GoogleMapsLoader expect to render nothing when it&apos;s loading" name="GoogleMapsLoader expect to render nothing when it&apos;s loading" time="0">
    </testcase>
    <testcase classname="GoogleMapsLoader expect to call children with the Google object when it&apos;s loaded" name="GoogleMapsLoader expect to call children with the Google object when it&apos;s loaded" time="0.003">
    </testcase>
    <testcase classname="GoogleMapsLoader expect to not call setState when we unmount before loading is complete" name="GoogleMapsLoader expect to not call setState when we unmount before loading is complete" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="connectHitInsights" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:06" time="0.914" tests="6">
    <testcase classname="connectHitInsights should expose an `insights` property" name="connectHitInsights should expose an `insights` property" time="0.003">
    </testcase>
    <testcase classname="connectHitInsights exposed `insights` should be a function" name="connectHitInsights exposed `insights` should be a function" time="0">
    </testcase>
    <testcase classname="connectHitInsights when called with `clickedRecordIDsAfterSearch` should forward call to insightsClient with the correct payload" name="connectHitInsights when called with `clickedRecordIDsAfterSearch` should forward call to insightsClient with the correct payload" time="0.001">
    </testcase>
    <testcase classname="connectHitInsights when called with `convertedObjectIDsAfterSearch` should forward call to insightsClient with the correct payload" name="connectHitInsights when called with `convertedObjectIDsAfterSearch` should forward call to insightsClient with the correct payload" time="0.001">
    </testcase>
    <testcase classname="connectHitInsights when called with an unsupported method should reject the call" name="connectHitInsights when called with an unsupported method should reject the call" time="0.001">
    </testcase>
    <testcase classname="connectHitInsights when queryID is undefined should throw an error message inviting to add clickAnalytics: true" name="connectHitInsights when queryID is undefined should throw an error message inviting to add clickAnalytics: true" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="createStore" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:06" time="0.737" tests="4">
    <testcase classname="createStore getState retrieves the current state of the store" name="createStore getState retrieves the current state of the store" time="0">
    </testcase>
    <testcase classname="createStore setState sets a new state" name="createStore setState sets a new state" time="0.001">
    </testcase>
    <testcase classname="createStore subscribe subscribes to new states" name="createStore subscribe subscribes to new states" time="0">
    </testcase>
    <testcase classname="createStore subscribe returns a method to unsubscribe" name="createStore subscribe returns a method to unsubscribe" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="connectHitsPerPage" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:06" time="0.918" tests="10">
    <testcase classname="connectHitsPerPage single index provides the correct props to the component" name="connectHitsPerPage single index provides the correct props to the component" time="0.041">
    </testcase>
    <testcase classname="connectHitsPerPage single index calling refine updates the widget&apos;s search state" name="connectHitsPerPage single index calling refine updates the widget&apos;s search state" time="0.001">
    </testcase>
    <testcase classname="connectHitsPerPage single index refines the perPage parameter" name="connectHitsPerPage single index refines the perPage parameter" time="0.001">
    </testcase>
    <testcase classname="connectHitsPerPage single index registers its id in metadata" name="connectHitsPerPage single index registers its id in metadata" time="0">
    </testcase>
    <testcase classname="connectHitsPerPage single index should return the right searchState when clean up" name="connectHitsPerPage single index should return the right searchState when clean up" time="0.001">
    </testcase>
    <testcase classname="connectHitsPerPage multi index provides the correct props to the component" name="connectHitsPerPage multi index provides the correct props to the component" time="0.002">
    </testcase>
    <testcase classname="connectHitsPerPage multi index calling refine updates the widget&apos;s search state" name="connectHitsPerPage multi index calling refine updates the widget&apos;s search state" time="0.001">
    </testcase>
    <testcase classname="connectHitsPerPage multi index correctly applies its state to search parameters" name="connectHitsPerPage multi index correctly applies its state to search parameters" time="0.001">
    </testcase>
    <testcase classname="connectHitsPerPage multi index registers its id in metadata" name="connectHitsPerPage multi index registers its id in metadata" time="0.001">
    </testcase>
    <testcase classname="connectHitsPerPage multi index should return the right searchState when clean up" name="connectHitsPerPage multi index should return the right searchState when clean up" time="0">
    </testcase>
  </testsuite>
  <testsuite name="connectStats" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:07" time="0.713" tests="2">
    <testcase classname="connectStats single index provides the correct props to the component" name="connectStats single index provides the correct props to the component" time="0">
    </testcase>
    <testcase classname="connectStats multi index provides the correct props to the component" name="connectStats multi index provides the correct props to the component" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="connectStateResults" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:07" time="0.724" tests="2">
    <testcase classname="connectStateResults single index provides the correct props to the component" name="connectStateResults single index provides the correct props to the component" time="0.001">
    </testcase>
    <testcase classname="connectStateResults multi index provides the correct props to the component" name="connectStateResults multi index provides the correct props to the component" time="0">
    </testcase>
  </testsuite>
  <testsuite name="connectAutoComplete" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:07" time="0.888" tests="9">
    <testcase classname="connectAutoComplete single index provides current hits to the component" name="connectAutoComplete single index provides current hits to the component" time="0.023">
    </testcase>
    <testcase classname="connectAutoComplete single index provides current hits to the component with queryID &amp; position" name="connectAutoComplete single index provides current hits to the component with queryID &amp; position" time="0.001">
    </testcase>
    <testcase classname="connectAutoComplete single index refines the query parameter" name="connectAutoComplete single index refines the query parameter" time="0.002">
    </testcase>
    <testcase classname="connectAutoComplete single index calling refine updates the widget&apos;s search state" name="connectAutoComplete single index calling refine updates the widget&apos;s search state" time="0">
    </testcase>
    <testcase classname="connectAutoComplete single index should return the right searchState when clean up" name="connectAutoComplete single index should return the right searchState when clean up" time="0">
    </testcase>
    <testcase classname="connectAutoComplete multi index provides current hits to the component" name="connectAutoComplete multi index provides current hits to the component" time="0.001">
    </testcase>
    <testcase classname="connectAutoComplete multi index refines the query parameter" name="connectAutoComplete multi index refines the query parameter" time="0">
    </testcase>
    <testcase classname="connectAutoComplete multi index calling refine updates the widget&apos;s search state" name="connectAutoComplete multi index calling refine updates the widget&apos;s search state" time="0">
    </testcase>
    <testcase classname="connectAutoComplete multi index should return the right searchState when clean up" name="connectAutoComplete multi index should return the right searchState when clean up" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="connectHits" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:07" time="0.676" tests="10">
    <testcase classname="connectHits single index provides the current hits to the component" name="connectHits single index provides the current hits to the component" time="0.001">
    </testcase>
    <testcase classname="connectHits single index adds positions to the hits provided to the component" name="connectHits single index adds positions to the hits provided to the component" time="0">
    </testcase>
    <testcase classname="connectHits single index adds queryID to the hits provided to the component" name="connectHits single index adds queryID to the hits provided to the component" time="0.001">
    </testcase>
    <testcase classname="connectHits single index doesn&apos;t render when no hits are available" name="connectHits single index doesn&apos;t render when no hits are available" time="0">
    </testcase>
    <testcase classname="connectHits single index should return the searchParameters unchanged" name="connectHits single index should return the searchParameters unchanged" time="0">
    </testcase>
    <testcase classname="connectHits multi index provides the current hits to the component" name="connectHits multi index provides the current hits to the component" time="0">
    </testcase>
    <testcase classname="connectHits multi index adds positions to the hits provided to the component" name="connectHits multi index adds positions to the hits provided to the component" time="0">
    </testcase>
    <testcase classname="connectHits multi index adds queryID to the hits provided to the component" name="connectHits multi index adds queryID to the hits provided to the component" time="0.001">
    </testcase>
    <testcase classname="connectHits multi index doesn&apos;t render when no hits are available" name="connectHits multi index doesn&apos;t render when no hits are available" time="0">
    </testcase>
    <testcase classname="connectHits multi index should return the searchParameters unchanged" name="connectHits multi index should return the searchParameters unchanged" time="0.001">
    </testcase>
  </testsuite>
  <testsuite name="GoogleMapsLoader" errors="0" failures="0" skipped="0" timestamp="2020-04-17T23:00:07" time="0.789" tests="1">
    <testcase classname="GoogleMapsLoader expect to require the file in a Node environment" name="GoogleMapsLoader expect to require the file in a Node environment" time="0.062">
    </testcase>
  </testsuite>
</testsuites>